# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Lablup Inc.
# This file is distributed under the same license as the Backend.AI Console
# Essential Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Backend.AI Console Essential Guide Enterprise R2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-07 22:44+0900\n"
"PO-Revision-Date: 2020-12-07 22:44+0900\n"
"Last-Translator: \n"
"Language: ko_KR\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 2.4.2\n"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:3
msgid "CPU/Memory Allocation and Using Compute Sessions"
msgstr "컨테이너 별 CPU, 메모리 자원 할당 및 연산 세션 활용"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:5
msgid "Objectives"
msgstr "목표"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:7
msgid ""
"From the GUI environment, users can create a compute session by specifying the "
"amount of CPU and memory resources dynamically"
msgstr "GUI 환경에서 CPU, 메모리 자원 옵션을 동적으로 주고 연산 세션을 생성"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:9
msgid "From the GUI, check the amount of CPU and memory resources of the session"
msgstr ""
"GUI 상에서 해당 세션의 CPU, 메모리 할당량을 확인하고 요청한 양에 맞게 생성되는"
"지 확인"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:10
msgid "Using Jupyter Notebook and Terminal apps in container environment"
msgstr "GUI 상에서 Jupyter Notebook 앱을 띄워 컨테이너 환경에서 노트북 사용"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:11
msgid ""
"Check the allocated CPU and memory resources from inside the container by "
"referencing cgroup"
msgstr "cgroup을 통한 자원 조회 후 컨테이너 수준의 자원 제약 여부 확인"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:14
msgid ""
"The most visited pages in the Backend.AI GUI Console would be the Sessions and "
"Storage pages. On the Sessions page, you can view, create, and use container-"
"based compute sessions, and on the Storage page, you can create a storage "
"folder to keep important data. Here, you will learn how to create container-"
"based compute sessions and utilize various web applications on the Sessions "
"page."
msgstr ""
"Backend.AI GUI Console에서 가장 많이 방문하게 될 페이지는 Sessions와 Storage 페"
"이지입니다. Sessions 페이지에서는 컨테이너 기반의 연산 세션을 조회하거나 생성 "
"및 사용할 수 있고, Storage 페이지에서는 데이터를 보관하는 저장 폴더를 생성할 수 "
"있습니다. 여기서는 Sessions 페이지에서 컨테이너 기반의 연산 세션을 생성하고 각"
"종 웹 애플리케이션을 활용하는 방법을 알아봅니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:23
msgid "Start a new session"
msgstr "연산 세션 생성하기"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:25
msgid ""
"After logging in with a user account, click Sessions on the left menu to visit "
"the Sessions page."
msgstr ""
"사용자 계정으로 로그인 후 좌측 메뉴의 Sessions를 클릭하여 Sessions 페이지로 이동"
"합니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:30
msgid ""
"Click the START button to start a new compute session. The following setup "
"dialog will appear. You can specify the language environment (Environments, "
"Version) and resources you want to allocate. Set the CPU and memory as shown in "
"the following figure and click the LAUNCH button. The environment was chosen as "
"TensorFlow 2.2."
msgstr ""
"새로운 연산 세션을 시작하려면 START 버튼을 클릭하세요. 다음과 같은 설정 창이 뜨"
"는데, 사용하려는 언어 환경(Environments, Version)과 자원을 설정할 수 있습니다. "
"다음 그림과 같이 CPU, 메모리 자원을 설정하고 LAUNCH 버튼을 클릭합니다. 환경은 "
"TensorFlow 2.2로 선택하였습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:40
msgid "If you need more detailed settings, refer to the meaning of each items."
msgstr "보다 상세한 설정이 필요한 경우, 다음 각 항목의 의미를 참조하세요."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:42
msgid ""
"Environment: Specify the default environment for compute sessions such as "
"TensorFlow, PyTorch, C++, and etc. When you select a TensorFlow environment, "
"your compute session will automatically include the TensorFlow library. If you "
"select another environment, the corresponding environment is installed by "
"default."
msgstr ""
"Environment: TensorFlow, PyTorch, C++ 등과 같은 연산 세션의 기본 환경을 지정합니"
"다. TensorFlow 환경을 선택하면 연산 세션이 TensorFlow 라이브러리를 자동으로 포함"
"하게 됩니다. 다른 환경을 선택하면 그에 해당하는 환경이 기본으로 설치됩니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:47
msgid ""
"Version: Select the version of the environment. For example, for TensorFlow "
"environment, you can select different versions such as 1.15, 2.3, etc."
msgstr ""
"Version: 환경의 버전을 선택합니다. 예를 들어, TensorFlow 환경에는 1.15, 2.3 등"
"과 같은 버전을 구분해서 선택할 수 있습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:49
msgid ""
"Resource Group: Specify the resource group in which to create the compute "
"session. If there are multiple resource groups, you can select the desired "
"value, but if there is only one resource group, it cannot be changed."
msgstr ""
"Resource Group: 연산 세션을 생성할 리소스 그룹을 지정합니다. 리소스 그룹이 여러 "
"개 있을 경우, 원하는 값을 선택할 수 있으나, 하나의 리소스 그룹만 있는 경우에는 "
"변경할 수 업습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:52
msgid ""
"Session name (optional): Specifies the name of the compute session to be "
"created. If specified, this name appears in Session Info, making it easy to "
"distinguish from other compute sessions. If not specified, a randomly-generated "
"name is used. You can set up to 4 to 64 characters, and no spaces are allowed."
msgstr ""
"Session name (optional): 생성할 연산 세션의 이름을 지정합니다. 지정하면 Session "
"Info에 이 이름이 나타나므로 연산 세션의 구분이 용이합니다. 지정하지 않으면 임의"
"의 이름을 사용합니다. 4-64자 까지 설정 가능하며, 공백은 허용되지 않습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:57
msgid ""
"Folder to mount: Specifies the data folder to be mounted in the compute "
"session. When a compute session is deleted, by default all data is deleted "
"altogether, but the data stored in the folder mounted here is not deleted."
msgstr ""
"Folder to mount: 연산 세션에 마운트 할 데이터 폴더를 지정합니다. 연산 세션이 삭"
"제되면 기본적으로 모든 데이터가 함께 삭제되지만, 여기서 마운트 한 폴더에 저장된 "
"데이터는 삭제되지 않습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:60
msgid ""
"Resource allocation: This is a template that has predefined resources to be "
"allocated to the compute session. You can save and use frequently used resource "
"settings in advance. Resource templates can be managed in a dedicated admin hub."
msgstr ""
"Resource allocation: 연산 세션에 할당할 자원을 사전 정의해 둔 템플릿입니다. 자"
"주 사용하는 자원 설정을 미리 저장해두고 사용할 수 있습니다. 자원 템플릿은 관리"
"자 전용 Hub에서 관리할 수 있습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:64
msgid ""
"CPU: The number of CPU cores to allocate to the compute session. The maximum "
"value depends on the resource policy applied to the user."
msgstr ""
"CPU: 연산 세션에 할당할 CPU 코어의 수. 최대값은 사용자에게 적용되는 자원 정책에 "
"따라 달라집니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:66
msgid ""
"RAM: The amount of memory (GB) to allocate for the compute session. The maximum "
"value depends on the resource policy applied to the user."
msgstr ""
"RAM: 연산 세션에 할당할 메모리의 용량 (GB). 최대값은 사용자에게 적용되는 자원 정"
"책에 따라 달라집니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:68
msgid ""
"Shared Memory: The amount of shared memory (GB) to allocate for the compute "
"session. It can only be set up to 2 GB, and cannot be greater than the amount "
"specified in RAM."
msgstr ""
"Shared Memory: 연산 세션에 할당할 공유 메모리의 용량 (GB). 최대 2 GB 까지만 설정"
"할 수 있으며, RAM에 지정된 양보다 클 수 없습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:71
msgid ""
"GPU: The unit of GPU to allocate to the compute session. The maximum value "
"depends on the resource policy applied to the user."
msgstr ""
"GPU: 연산 세션에 할당할 GPU 단위. 최대값은 사용자에게 적용되는 자원 정책에 따라 "
"달라집니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:73
msgid ""
"Sessions: The number of compute sessions to be created with the specified "
"settings. You can specify when you need to create the same computational "
"sessions at once."
msgstr ""
"Sessions: 지정된 설정으로 생성할 연산 세션의 수. 동일한 연산 세션을 한꺼번에 생"
"성할 필요가 있을 때 지정할 수 있습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:77
msgid ""
"If no mount folder is specified in the Folder to mount input box, a warning "
"dialog may appear indicating that the storage folder is not mounted. For now, "
"ignore the warning and click the LAUNCH WITHOUT STORAGE FOLDER button to create "
"a compute session. Let's see that a new compute session is created in the "
"Running tab. In the FINISHED tab, you can see terminated compute sessions, and "
"in the OTHERS tab you can query for compute sessions with errors."
msgstr ""
"이 때, Folder to mount 입력칸에 아무 마운트 폴더도 지정하지 않은 경우 저장 폴더"
"가 마운트 되지 않았다는 경고 창이 뜰 수 있습니다. 일단은 경고를 무시하고 LAUNCH "
"WITHOUT STORAGE FOLDER 버튼을 클릭하여 연산 세션을 생성합니다. RUNNING 탭에서 새"
"로운 연산 세션이 생성되는 것을 확인합시다. FINISHED 탭에서는 종료된 연산 세션"
"을, OTHERS 탭에서는 오류가 발생한 연산 세션을 조회할 수 있습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:86
msgid ""
"You can check information such as ID, start date, usage time, resource setting, "
"and resource usage for each session. In particular, check the allocated "
"resources in the Configuration column. Note that the amounts of resources you "
"specified in creating the compute session are displayed."
msgstr ""
"각 세션 별 ID, 시작일, 사용시간, 자원 설정, 사용량 등의 정보를 확인할 수 있습니"
"다. 특히 Configuration 열의 자원 할당량을 확인 하십시오. 연산 세션을 생성할 때 "
"지정한 자원량이 출력되는 것을 확인할 수 있습니다. "

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:92
msgid ""
"Superadmins can view all compute session information currently running (or "
"terminated) in the cluster, and users can view only the sessions they have "
"created."
msgstr ""
"수퍼어드민의 경우 현재 클러스터에서 실행 중인 (또는 종료된) 모든 세션 정보를 확"
"인할 수 있고, 일반 사용자의 경우에는 자신이 사용한 세션만 조회 가능합니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:97
msgid ""
"Compute session list may not be displayed normally due to intermittent network "
"connection problems, and etc. This can be solved by refreshing the browser page."
msgstr ""
"간헐적인 네트워크 접속 불량 등의 문제로 세션 리스트가 정상적으로 표시되지 않는 "
"경우가 발생할 수 있습니다. 이 때는 브라우저 페이지를 갱신해서 해결할 수 있습니"
"다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:102
msgid ""
"Utilize Jupyter Notebook and check the resource quota from inside the container"
msgstr "Jupyter Notebook 앱 활용 및 컨테이너 내부의 자원 할당량 확인"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:104
msgid ""
"Let's look at how to use and manage compute sessions that are already running. "
"If you look at the Control column of the session list, there are several icons. "
"When you click the first icon, the app launcher appears as shown in the figure "
"below, and several app services supported by the session appear."
msgstr ""
"이미 실행 중인 연산 세션을 사용하고 관리하는 법에 관해 살펴보겠습니다. 세션 리스"
"트의 Control 열을 보면 몇 가지 아이콘이 있습니다. 제일 첫 아이콘을 클릭하면 다"
"음 그림과 같이 앱 런처가 뜨면서 해당 세션이 지원하는 몇 가지 앱 서비스가 뜨게 됩"
"니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:113
msgid "Let's click on Jupyter Notebook."
msgstr "Jupyter Notebook을 클릭해봅시다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:116
msgid ""
"Try preferred port: When the web service is opened, a specific port is assigned "
"from the port pool created in advance by Backend.AI. Users can use the service "
"only when they connect to the port along with the IP address or domain name. If "
"you check this item and enter the port number, the entered port number will be "
"tried. However, there is no guarantee that the desired port will always be "
"assigned. The port may not exist at all in the port pool, or another service "
"may already be using the port.In this case, the port number is randomly "
"assigned. Do not open the app by checking this option unless you have a clear "
"usage purpose and know what it means."
msgstr ""
"Try preferred port: 웹 서비스가 뜰 때 Backend.AI가 사전에 생성해 둔 포트 풀"
"(pool)에서 특정 포트를 하나 할당받게 됩니다. 사용자는 IP주소 또는 도메인 이름과 "
"함께 해당 포트로 접속을 해야 서비스를 사용할 수 있습니다. 이 항목에 체크하고 포"
"트 번호를 입력하면 입력한 포트 번호를 우선적으로 할당 시도하게 됩니다. 하지만, "
"항상 원하는 포트를 할당받는다는 보장은 없습니다. 포트 풀에 해당 포트가 아예 없"
"을 수도 있고, 다른 서비스가 이미 해당 포트를 할당받아 사용하고 있을 수도 있습니"
"다. 이런 경우에는 임의로 포트 번호를 할당합니다. 확실한 사용 목적이 없다면 이 항"
"목을 체크해서 앱을 띄우지 마십시오."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:129
msgid ""
"A new window pops up and you can see that Jupyter Notebook is running. This "
"notebook was created inside a running compute session and can be used easily "
"with the click of a button without any other settings. Also, there is no need "
"for a separate package installation process because the language environment "
"and library provided by the computation session can be used as it is. For "
"detailed instructions on how to use Jupyter Notebook, please refer to the "
"official documentation."
msgstr ""
"새로운 창이 뜨면서 Jupyter Notebook이 실행되는 것을 확인할 수 있습니다. 이 "
"Notebook은 실행 중인 연산 세션 내부에서 생성된 것으로, 별다른 설정 없이 버튼 클"
"릭만으로 손쉽게 사용할 수 있습니다. 또한, 연산 세션이 기본적으로 제공하는 언어 "
"환경 및 라이브러리를 그대로 활용할 수 있어 별도의 패키지 설치 과정이 필요 없습니"
"다. 자세한 Jupyter Notebook 사용법은 공식 문서 등을 참고하시기 바랍니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:137
msgid ""
"Click the NEW button on the top right and select the Notebook for Backend.AI, "
"then the ipynb window appears where you can enter your own code."
msgstr ""
"우측 상단의 NEW 버튼을 클릭한 후 Backend.AI 용 Notebook을 선택하면 새로운 코드"
"를 입력할 수 있는 ipynb 창이 뜹니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:144
msgid ""
"In this window, you can enter and execute any code you want by using the "
"environment that session provides. The code execution happens on one of the "
"Backend.AI nodes where the compute session is actually created, and there is no "
"need to configure a separate environment on the local machine. Enter the "
"following code and click the Run button or type ``Ctrl-Enter`` to run the code. "
"It is a Python code that reads and prints the resource quota under ``/sys/fs/"
"cgroup/``."
msgstr ""
"이 창에서 세션 환경에 맞는 코드를 입력하고 실행해볼 수 있습니다. 코드는 Backend."
"AI 서버를 구성하는 노드 중 연산 세션이 실제로 생성된 노드에서 실행이 되며, 로컬 "
"머신에는 별도 환경을 구성할 필요가 없습니다. 다음과 같은 코드를 입력하고 실행 버"
"튼을 클릭하거나 ``Ctrl-Enter`` 를 입력하여 코드를 실행해봅니다. ``/sys/fs/"
"cgroup/`` 하위에 있는 자원 할당량을 읽고 출력하는 파이썬 코드입니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:154
msgid ""
"Since Python is already installed in the TensorFlow 2.2 environment, the code "
"will run without any configuration. Make sure that the amount of core and "
"memory you specified when you first created the compute session is displayed."
msgstr ""
"TensorFlow 2.2 환경에는 이미 파이썬이 설치되어 있으므로, 별다른 설정 없이 코드"
"가 실행될 것입니다. 처음 연산 세션을 생성할 때 지정했던 코어와 메모리 량이 출력"
"되는 것을 확인하십시오."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:159
msgid ""
"The amount of memory may vary slightly depending on the calculation method."
msgstr "메모리 양은 계산 방식의 차이에 따라 값이 다소 차이날 수 있습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:161
msgid ""
"Like this, after creating a compute session, you can use web apps such as "
"Jupyter Notebook, and in Jupyter Notebook, you can run Python code that checks "
"resource constraints right away without installing a separate packages."
msgstr ""
"이처럼 연산 세션을 생성한 후 Jupyter Notebook 등과 같은 웹 앱을 사용할 수 있으"
"며, Jupyter Notebook에서는 별도의 설치를 하지 않고 바로 자원 제약 상황을 확인하"
"는 Python 코드를 실행할 수 있었습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:167
msgid "Web terminal"
msgstr "웹 터미널 활용"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:169
msgid ""
"If you close the Jupyter Notebook app and open the app launcher screen of the "
"math session again, you will see the Console app present. Let's click."
msgstr ""
"Jupyter Notebook 앱을 닫고 다시 연산 세션의 앱 런처 화면을 열면 Console 앱이 있"
"는 것을 볼 수 있습니다. 클릭 해봅시다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:176
msgid ""
"A terminal will also appear in a new window, and you can issue shell commands "
"by accessing inside the computational session as shown in the following figure. "
"If you are familiar with using commands, you can easily issue various Linux "
"commands. You can see that the Untitled.ipynb file automatically generated in "
"Jupyter Notebook is viewed through the ``ls`` command. This is proof that both "
"apps are running in the same container environment."
msgstr ""
"터미널 역시 새 창에서 뜨게 되며, 다음 그림처럼 연산 세션 내부에 접속해서 쉘 명령"
"을 내릴 수 있습니다. 커맨드 사용에 익숙한 분이라면 손쉽게 여러 가지 리눅스 명령"
"을 내릴 수가 있습니다. Jupyter Notebook에서 자동 생성된 Untitled.ipynb 파일이 "
"``ls`` 명령을 통해 조회되는 것을 볼 수 있습니다. 두 앱이 같은 컨테이너 환경에서 "
"돌아가고 있다는 증거입니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:183
msgid ""
"In addition to this, you can use web-based services such as TensorBoard, "
"Jupyter Lab, etc., depending on the type of service provided by the compute "
"session."
msgstr ""
"이 외에도 연산 세션이 제공하는 서비스의 종류에 따라 TensorBoard, Jupyter Lab 등"
"과 같은 웹 기반 서비스를 이용할 수 있습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:186
msgid "To delete a specific session, simply click on the red power icon."
msgstr "특정 세션을 삭제하기 위해서는 빨간색 전원 아이콘을 클릭하면 됩니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:194
msgid "Query compute session log"
msgstr "연산 세션 로그 조회"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:196
msgid ""
"You can view the log of the compute session by clicking the last icon in the "
"Control column of the running compute session."
msgstr ""
"돌아가고 있는 연산 세션의 Control 열의 마지막 아이콘을 클릭하면 연산 세션의 로그"
"를 조회할 수 있습니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:205
msgid "Delete a compute session"
msgstr "연산 세션 삭제하기"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:207
msgid ""
"You can delete a compute session by clicking the trash can icon in the Control "
"column of the running session. If you click OKAY button in the dialog box, the "
"compute session will be deleted after a while."
msgstr ""
"돌아가고 있는 연산 세션의 Control 열에 있는 휴지통 아이콘을 클릭하면 연산 세션"
"을 삭제할 수 있습니다. 다이얼로그에서 OKAY 버튼을 클릭하면 잠시 후 연산 세션이 "
"삭제 됩니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:217
msgid "Session List Download"
msgstr "세션 리스트 다운로드"

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:219
msgid ""
"On the right side of the OTHERS tab there is a menu marked with ``...``. When "
"you click this menu, a sub-menu export CSV appears."
msgstr ""
"OTHERS 탭 우측을 보면 ``…`` 으로 표시된 메뉴가 있습니다. 이 메뉴를 클릭하면 "
"export CSV 라는 하위 메뉴가 나옵니다."

#: ../../allocate_cpu_mem/allocate_cpu_mem.rst:224
msgid ""
"If you click this menu, you can download the information of the calculation "
"sessions created so far in CSV format. After the following dialog opens, enter "
"an appropriate file name (if necessary) and click the EXPORT button. A CSV file "
"will be downloaded soon."
msgstr ""
"이 메뉴를 클릭하면 현재까지 생성된 연산 세션의 정보를 CSV 형태로 다운로드 받을 "
"수 있습니다. 다음과 같은 다이얼로그가 열린 후, (필요한 경우) 적당한 파일 이름을 "
"입력하고 EXPORT 버튼을 클릭하십시오. 곧 CSV 파일 하나가 다운로드 될 것입니다."
