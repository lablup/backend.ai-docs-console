# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Lablup Inc.
# This file is distributed under the same license as the Backend.AI Console
# Essential Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Backend.AI Console Essential Guide Enterprise R2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-11 21:08+0900\n"
"PO-Revision-Date: 2020-09-11 21:10+0900\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko_KR\n"
"X-Generator: Poedit 2.4.1\n"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:3
msgid "Resource Monitoring and Automated Job Scheduling"
msgstr "GUI를 통한 리소스 모니터링 및 스케줄링 자동화"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:5
msgid "Objectives"
msgstr "목표"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:7
msgid ""
"Confirm that the change in resource usage status is displayed on the GUI "
"after creating a compute session."
msgstr "연산 세션 생성 후 자원 사용 현황 변화가 GUI 상에서 표시됨을 확인"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:9
msgid ""
"When creating a compute session by setting resources more than the "
"allowed amounts, the scheduler keeps the request on the job queue and "
"marks it as in the PENDING state."
msgstr ""
"허용된 자원 이상을 설정하여 연산 세션을 생성하면 요청이 작업 큐에 들어가"
"고 PENDING 상태로 대기함을 확인"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:12
msgid ""
"Check that the PENDING session is automatically scheduled and converted "
"to the RUNNING state just after resources are available."
msgstr ""
"가용 자원이 다시 생기는 순간 PENDING 세션이 스케줄링 되어 실행 상태로 바"
"뀜을 확인"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:17
msgid "Resource monitoring through GUI"
msgstr "GUI를 통한 리소스 모니터링"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:19
msgid ""
"Backend.AI GUI Console supports resource monitoring through GUI. After "
"logging in with a user account, create a compute session. Resource "
"allocation is set as shown in the following figure."
msgstr ""
"Backend.AI GUI Console은 GUI를 통한 리소스 모니터링을 지원합니다. 사용자 "
"계정으로 로그인 한 후 연산 세션을 생성합니다. 자원 할당은 다음 그림과 같"
"이 해보겠습니다."

#: ../../resource_and_scheduler/resource_and_scheduler.rst:27
msgid ""
"After creating a compute session by clicking the LAUNCH button, you can "
"see that the amount of resources allocated by CPU, RAM, and FGPU in the "
"upper resource indicator increases."
msgstr ""
"LAUNCH 버튼을 클릭하여 연산 세션을 생성 한 후 상단의 리소스 인디케이터의 "
"CPU, RAM, FGPU가 할당한 리소스 양만큼 증가하는 것을 확인할 수 있습니다."

#: ../../resource_and_scheduler/resource_and_scheduler.rst:35
msgid ""
"Next, let's delete the compute session we just created. End the session "
"by pressing the red power button in the Control column."
msgstr ""
"이번에는 생성한 연산 세션을 삭제해보겠습니다. Control 열의 붉은 전원 버튼"
"을 눌러 세션을 종료 하십시오."

#: ../../resource_and_scheduler/resource_and_scheduler.rst:42
msgid ""
"After the compute session disappears from the list, you can see that the "
"CPU, RAM, and FGPU of the resource indicator decrease by the exact "
"amount of resources."
msgstr ""
"연산 세션이 리스트에서 사라지고 곧 이어 리소스 인디케이터의 CPU, RAM, "
"FGPU가 해당 리소스 만큼 감소하는 것을 확인할 수 있습니다."

#: ../../resource_and_scheduler/resource_and_scheduler.rst:52
msgid "Job scheduler"
msgstr "작업 스케줄러"

#: ../../resource_and_scheduler/resource_and_scheduler.rst:54
msgid ""
"Backend.AI server has a built-in self-developed task scheduler. It "
"automatically checks the available resources of all worker nodes and "
"delegates the request to create a compute session to the worker that "
"meets the user's resource request. In addition, when resources are "
"insufficient, the user's request to create a compute session is "
"registered as a PENDING state in the job queue. Later, when the resource "
"becomes available again, the PENDING request is activated to perform "
"compute session creation."
msgstr ""
"Backend.AI 서버는 자체 개발한 작업 스케줄러를 내장하고 있습니다. 자동으"
"로 모든 워커(worker) 노드의 자원 상태를 확인하여 사용자의 리소스 요청에 "
"맞는 워커로 연산 세션 생성 요청을 위임 합니다. 또한, 자원이 부족할 경우에"
"는 일단 작업 큐에 사용자의 연산 세션 생성 요청을 대기(pending) 시키고 나"
"중에 자원이 다시 가용 상태가 되면 대기 요청을 활성화 해서 연산 세션 생성 "
"작업을 수행하게 됩니다."

#: ../../resource_and_scheduler/resource_and_scheduler.rst:62
msgid ""
"You can also check the operation of the job scheduler in a simple way "
"from the user GUI console. Currently, our GPU host can allocate up to 2 "
"fGPUs of resources. Now let's create 3 compute sessions at the same time "
"requesting allocation of resources equal to 1 fGPU. At the bottom of the "
"session launch dialog, there are GPU and Sessions sliders. If you "
"specify a value greater than 1 in Sessions, when the LAUNCH button is "
"clicked, the number of sessions will be requested at the same time. "
"Let's set the GPU and Sessions to 1 and 3, respectively. In a situation "
"where only 2 fGPUs exists, 3 sessions requesting a total of 3 fGPU "
"resources are created."
msgstr ""
"사용자 GUI 콘솔에서도 간단한 방법으로 작업 스케줄러의 동작을 확인해볼 수 "
"있습니다. 현재 테스트 GPU 호스트에는 최대 2 fGPU 만큼의 자원이 할당 가능"
"합니다. 이제 1 fGPU 만큼의 자원 할당을 요청하는 연산 세션 3개를 동시에 생"
"성해 보겠습니다. 연산 세션 생성 다이얼로그 하단을 보면 GPU와 Sessions 슬"
"라이더가 있습니다. Sessions에 값을 1보다 크게 지정하면 LAUNCH 버튼을 클릭"
"했을 때 해당 갯수만큼의 세션을 동시에 생성 요청하게 됩니다. GPU와 "
"Sessions를 각각 1, 3으로 설정해보겠습니다. 2 fGPU만 존재하는 상황에서 총 "
"3 fGPU 리소스를 요청하는 세션이 3개 생성되는 것입니다."

#: ../../resource_and_scheduler/resource_and_scheduler.rst:76
msgid ""
"Wait for a while and you will see three compute sessions being listed. "
"At this time, if you look closely at the Status column, you can see that "
"two of the three compute sessions are in RUNNING state, but the other "
"compute session remains in the PENDING state. This PENDING session is "
"only registered in the job queue and has not actually been allocated a "
"container due to insufficient GPU resources."
msgstr ""
"잠시 기다리면 세 개의 연산 세션이 조회되는 것을 알 수 있습니다. 이 때, "
"Status 열을 자세히 보면 세 개 중 두 개 연산 세션의 상태는 RUNNING이지만, "
"다른 하나의 연산 세션은 PENDING 상태에 머물러 있는 것을 확인할 수 있습니"
"다. 이 PENDING 세션은 작업 큐에 등록만 되어 있고 GPU 자원 부족으로 인해 "
"실제로 컨테이너를 할당 받지는 못한 상태입니다."

#: ../../resource_and_scheduler/resource_and_scheduler.rst:87
msgid ""
"Now let's destroy one of the two sessions in the RUNNING state. Then you "
"can see that the compute session in the PENDING state will soon be "
"allocated resources by the job scheduler and converted to the RUNNING "
"state. In this way, the job scheduler utilizes the job queue to hold the "
"user's compute session requests, and then automatically process the "
"requests when resources become available."
msgstr ""
"이제 RUNNING 상태의 세션 두 개 중 하나를 삭제 해보겠습니다. 그러면 "
"PENDING 상태의 연산 세션은 곧 작업 스케줄러에 의해 자원을 할당 받고 "
"RUNNING 상태로 변환되는 것을 볼 수 있습니다. 이처럼, 작업 스케줄러는 작"
"업 큐를 활용해 사용자의 연산 세션 요청을 간직하고 있다가 자원이 가용해질 "
"때 자동으로 요청을 처리하게 됩니다."
